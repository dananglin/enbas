/*
   This file is generated by the enbas-codegen
   DO NOT EDIT.
*/

package executor

import (
	"flag"
	"os"

	"codeflow.dananglin.me.uk/apollo/enbas/internal/config"
	internalFlag "codeflow.dananglin.me.uk/apollo/enbas/internal/flag"
	"codeflow.dananglin.me.uk/apollo/enbas/internal/printer"
	"codeflow.dananglin.me.uk/apollo/enbas/internal/usage"
)

func Execute() error {
	var (
		configDir   string
		noColorFlag internalFlag.BoolPtrValue
		noColor     bool
	)

	flag.StringVar(&configDir, "config-dir", "", "The path to your configuration directory")
	flag.Var(&noColorFlag, "no-color", "Set to true to disable ANSI colour output when displaying text on screen")

	flag.Usage = usage.AppUsageFunc()

	flag.Parse()

	if flag.NArg() < 1 {
		flag.Usage()

		return nil
	}

	if noColorFlag.Value != nil {
		noColor = *noColorFlag.Value
	} else if os.Getenv("NO_COLOR") != "" {
		noColor = true
	}

	command := flag.Arg(0)
	args := flag.Args()[1:]

	executorMap := map[string]func(string, bool, []string) error{
		"accept":   ExecuteAcceptCommand,
		"add":      ExecuteAddCommand,
		"block":    ExecuteBlockCommand,
		"create":   ExecuteCreateCommand,
		"delete":   ExecuteDeleteCommand,
		"edit":     ExecuteEditCommand,
		"follow":   ExecuteFollowCommand,
		"init":     ExecuteInitCommand,
		"login":    ExecuteLoginCommand,
		"mute":     ExecuteMuteCommand,
		"reject":   ExecuteRejectCommand,
		"remove":   ExecuteRemoveCommand,
		"server":   ExecuteServerCommand,
		"show":     ExecuteShowCommand,
		"switch":   ExecuteSwitchCommand,
		"unblock":  ExecuteUnblockCommand,
		"unfollow": ExecuteUnfollowCommand,
		"unmute":   ExecuteUnmuteCommand,
		"version":  ExecuteVersionCommand,
		"whoami":   ExecuteWhoamiCommand,
	}

	executorFunc, ok := executorMap[command]
	if !ok {
		err := UnknownCommandError{command: command}
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"Error: "+err.Error(),
		)

		return err
	}

	return executorFunc(configDir, noColor, args)
}

// AcceptExecutor is the executor for the accept command.
type AcceptExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	resourceType  string
	configDir     string
}

// ExecuteAcceptCommand initialises and runs the executor for the accept command.
func ExecuteAcceptCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := AcceptExecutor{
		FlagSet:       flag.NewFlagSet("accept", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("accept", "Accepts a request (e.g. a follow request)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(accept) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(accept) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(accept) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// AddExecutor is the executor for the add command.
type AddExecutor struct {
	*flag.FlagSet
	printSettings  printer.Settings
	config         *config.Config
	accountNames   internalFlag.StringSliceValue
	content        string
	listID         string
	statusID       string
	toResourceType string
	resourceType   string
	votes          internalFlag.IntSliceValue
	configDir      string
}

// ExecuteAddCommand initialises and runs the executor for the add command.
func ExecuteAddCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := AddExecutor{
		FlagSet:       flag.NewFlagSet("add", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountNames:  internalFlag.NewStringSliceValue(),
		votes:         internalFlag.NewIntSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("add", "Adds a resource to another resource", exe.FlagSet)

	exe.Var(&exe.accountNames, "account-name", "The name of the account")
	exe.StringVar(&exe.content, "content", "", "The content of the created resource")
	exe.StringVar(&exe.listID, "list-id", "", "The ID of the list in question")
	exe.StringVar(&exe.statusID, "status-id", "", "The ID of the status")
	exe.StringVar(&exe.toResourceType, "to", "", "The resource type to action the target resource to (e.g. status)")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")
	exe.Var(&exe.votes, "vote", "Add a vote to an option in a poll")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(add) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(add) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(add) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// BlockExecutor is the executor for the block command.
type BlockExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	resourceType  string
	configDir     string
}

// ExecuteBlockCommand initialises and runs the executor for the block command.
func ExecuteBlockCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := BlockExecutor{
		FlagSet:       flag.NewFlagSet("block", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("block", "Blocks a resource (e.g. an account)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(block) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(block) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(block) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// CreateExecutor is the executor for the create command.
type CreateExecutor struct {
	*flag.FlagSet
	printSettings             printer.Settings
	config                    *config.Config
	addPoll                   bool
	attachmentIDs             internalFlag.StringSliceValue
	content                   string
	contentType               string
	localOnly                 bool
	likeable                  bool
	replyable                 bool
	boostable                 bool
	inReplyTo                 string
	language                  string
	listExclusive             bool
	listRepliesPolicy         string
	listTitle                 string
	mediaDescriptions         internalFlag.StringSliceValue
	mediaFocusValues          internalFlag.StringSliceValue
	mediaFiles                internalFlag.StringSliceValue
	pollAllowsMultipleChoices bool
	pollExpiresIn             internalFlag.TimeDurationValue
	pollHidesVoteCounts       bool
	pollOptions               internalFlag.StringSliceValue
	sensitive                 internalFlag.BoolPtrValue
	summary                   string
	resourceType              string
	visibility                string
	configDir                 string
}

// ExecuteCreateCommand initialises and runs the executor for the create command.
func ExecuteCreateCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := CreateExecutor{
		FlagSet:           flag.NewFlagSet("create", flag.ExitOnError),
		printSettings:     printer.Settings{},
		config:            nil,
		configDir:         configDir,
		attachmentIDs:     internalFlag.NewStringSliceValue(),
		mediaDescriptions: internalFlag.NewStringSliceValue(),
		mediaFocusValues:  internalFlag.NewStringSliceValue(),
		mediaFiles:        internalFlag.NewStringSliceValue(),
		pollExpiresIn:     internalFlag.NewTimeDurationValue(),
		pollOptions:       internalFlag.NewStringSliceValue(),
		sensitive:         internalFlag.NewBoolPtrValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("create", "Creates a specific resource", exe.FlagSet)

	exe.BoolVar(&exe.addPoll, "add-poll", false, "Set to true to add a poll when creating a status")
	exe.Var(&exe.attachmentIDs, "attachment-id", "The ID of the media attachment")
	exe.StringVar(&exe.content, "content", "", "The content of the created resource")
	exe.StringVar(&exe.contentType, "content-type", "plain", "The type that the contents should be parsed from (valid values are plain and markdown)")
	exe.BoolVar(&exe.localOnly, "local-only", false, "Set to true to NOT federate the status beyond the local timeline(s)")
	exe.BoolVar(&exe.likeable, "enable-likes", true, "Set to true to allow the status to be liked (favourited)")
	exe.BoolVar(&exe.replyable, "enable-replies", true, "Set to true to allow viewers to reply to the status")
	exe.BoolVar(&exe.boostable, "enable-reposts", true, "Set to true to allow the status to be reposted (boosted) by others")
	exe.StringVar(&exe.inReplyTo, "in-reply-to", "", "The ID of the status that you want to reply to")
	exe.StringVar(&exe.language, "language", "", "The ISO 639 language code for this status")
	exe.BoolVar(&exe.listExclusive, "list-exclusive", false, "Set to true to hide posts from members of this list from your home timeline")
	exe.StringVar(&exe.listRepliesPolicy, "list-replies-policy", "list", "The replies policy of the list")
	exe.StringVar(&exe.listTitle, "list-title", "", "The title of the list")
	exe.Var(&exe.mediaDescriptions, "media-description", "The description of the media attachment which will be used as the alt-text")
	exe.Var(&exe.mediaFocusValues, "media-focus", "The focus of the media file")
	exe.Var(&exe.mediaFiles, "media-file", "The path to the media file")
	exe.BoolVar(&exe.pollAllowsMultipleChoices, "poll-allows-multiple-choices", false, "Set to true to allow viewers to make multiple choices in the poll")
	exe.Var(&exe.pollExpiresIn, "poll-expires-in", "The duration in which the poll is open for")
	exe.BoolVar(&exe.pollHidesVoteCounts, "poll-hides-vote-counts", false, "Set to true to hide the vote count until the poll is closed")
	exe.Var(&exe.pollOptions, "poll-option", "A poll option. Use this multiple times to set multiple options")
	exe.Var(&exe.sensitive, "sensitive", "Set to true if the status should be marked as sensitive")
	exe.StringVar(&exe.summary, "summary", "", "The summary of the status (a.k.a the subject, spoiler text or content warning)")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")
	exe.StringVar(&exe.visibility, "visibility", "", "The visibility of the posted status")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(create) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(create) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(create) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// DeleteExecutor is the executor for the delete command.
type DeleteExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	listID        string
	saveText      bool
	statusID      string
	resourceType  string
	configDir     string
}

// ExecuteDeleteCommand initialises and runs the executor for the delete command.
func ExecuteDeleteCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := DeleteExecutor{
		FlagSet:       flag.NewFlagSet("delete", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
	}

	exe.Usage = usage.ExecutorUsageFunc("delete", "Deletes a specific resource", exe.FlagSet)

	exe.StringVar(&exe.listID, "list-id", "", "The ID of the list in question")
	exe.BoolVar(&exe.saveText, "save-text", false, "Set to true to save the text of the deleted status")
	exe.StringVar(&exe.statusID, "status-id", "", "The ID of the status")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(delete) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(delete) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(delete) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// EditExecutor is the executor for the edit command.
type EditExecutor struct {
	*flag.FlagSet
	printSettings     printer.Settings
	config            *config.Config
	attachmentIDs     internalFlag.StringSliceValue
	listID            string
	listTitle         string
	listRepliesPolicy string
	mediaDescriptions internalFlag.StringSliceValue
	mediaFocusValues  internalFlag.StringSliceValue
	resourceType      string
	configDir         string
}

// ExecuteEditCommand initialises and runs the executor for the edit command.
func ExecuteEditCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := EditExecutor{
		FlagSet:           flag.NewFlagSet("edit", flag.ExitOnError),
		printSettings:     printer.Settings{},
		config:            nil,
		configDir:         configDir,
		attachmentIDs:     internalFlag.NewStringSliceValue(),
		mediaDescriptions: internalFlag.NewStringSliceValue(),
		mediaFocusValues:  internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("edit", "Edit a specific resource", exe.FlagSet)

	exe.Var(&exe.attachmentIDs, "attachment-id", "The ID of the media attachment")
	exe.StringVar(&exe.listID, "list-id", "", "The ID of the list in question")
	exe.StringVar(&exe.listTitle, "list-title", "", "The title of the list")
	exe.StringVar(&exe.listRepliesPolicy, "list-replies-policy", "", "The replies policy of the list")
	exe.Var(&exe.mediaDescriptions, "media-description", "The description of the media attachment which will be used as the alt-text")
	exe.Var(&exe.mediaFocusValues, "media-focus", "The focus of the media file")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(edit) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(edit) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(edit) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// FollowExecutor is the executor for the follow command.
type FollowExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	notify        bool
	showReposts   bool
	tag           string
	resourceType  string
	configDir     string
}

// ExecuteFollowCommand initialises and runs the executor for the follow command.
func ExecuteFollowCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := FollowExecutor{
		FlagSet:       flag.NewFlagSet("follow", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("follow", "Follow a resource (e.g. an account)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.BoolVar(&exe.notify, "notify", false, "Get notifications from statuses from the account you want to follow")
	exe.BoolVar(&exe.showReposts, "show-reposts", true, "Show reposts from the account you want to follow")
	exe.StringVar(&exe.tag, "tag", "", "The name of the tag")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(follow) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(follow) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(follow) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// InitExecutor is the executor for the init command.
type InitExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	configDir     string
}

// ExecuteInitCommand initialises and runs the executor for the init command.
func ExecuteInitCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := InitExecutor{
		FlagSet:       flag.NewFlagSet("init", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
	}

	exe.Usage = usage.ExecutorUsageFunc("init", "Creates a new configuration file in the specified configuration directory", exe.FlagSet)

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(init) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(noColor, "", 0)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(init) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// LoginExecutor is the executor for the login command.
type LoginExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	instance      string
	configDir     string
}

// ExecuteLoginCommand initialises and runs the executor for the login command.
func ExecuteLoginCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := LoginExecutor{
		FlagSet:       flag.NewFlagSet("login", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
	}

	exe.Usage = usage.ExecutorUsageFunc("login", "Logs into an account on GoToSocial", exe.FlagSet)

	exe.StringVar(&exe.instance, "instance", "", "The instance that you want to log into")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(login) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(login) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(login) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// MuteExecutor is the executor for the mute command.
type MuteExecutor struct {
	*flag.FlagSet
	printSettings     printer.Settings
	config            *config.Config
	accountName       internalFlag.StringSliceValue
	muteDuration      internalFlag.TimeDurationValue
	muteNotifications bool
	statusID          string
	resourceType      string
	configDir         string
}

// ExecuteMuteCommand initialises and runs the executor for the mute command.
func ExecuteMuteCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := MuteExecutor{
		FlagSet:       flag.NewFlagSet("mute", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
		muteDuration:  internalFlag.NewTimeDurationValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("mute", "Mutes a specific resource (e.g. an account)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.Var(&exe.muteDuration, "mute-duration", "Specify how long the mute should last for. To mute indefinitely, set this to 0s")
	exe.BoolVar(&exe.muteNotifications, "mute-notifications", false, "Set to true to mute notifications as well as posts")
	exe.StringVar(&exe.statusID, "status-id", "", "The ID of the status")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(mute) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(mute) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(mute) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// RejectExecutor is the executor for the reject command.
type RejectExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	resourceType  string
	configDir     string
}

// ExecuteRejectCommand initialises and runs the executor for the reject command.
func ExecuteRejectCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := RejectExecutor{
		FlagSet:       flag.NewFlagSet("reject", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("reject", "Rejects a request (e.g. a follow request)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(reject) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(reject) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(reject) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// RemoveExecutor is the executor for the remove command.
type RemoveExecutor struct {
	*flag.FlagSet
	printSettings    printer.Settings
	config           *config.Config
	accountNames     internalFlag.StringSliceValue
	fromResourceType string
	listID           string
	statusID         string
	resourceType     string
	configDir        string
}

// ExecuteRemoveCommand initialises and runs the executor for the remove command.
func ExecuteRemoveCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := RemoveExecutor{
		FlagSet:       flag.NewFlagSet("remove", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountNames:  internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("remove", "Removes a resource from another resource", exe.FlagSet)

	exe.Var(&exe.accountNames, "account-name", "The name of the account")
	exe.StringVar(&exe.fromResourceType, "from", "", "The resource type to action the target resource from (e.g. status)")
	exe.StringVar(&exe.listID, "list-id", "", "The ID of the list in question")
	exe.StringVar(&exe.statusID, "status-id", "", "The ID of the status")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(remove) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(remove) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(remove) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// ServerExecutor is the executor for the server command.
type ServerExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	noIdleTimeout bool
	configDir     string
}

// ExecuteServerCommand initialises and runs the executor for the server command.
func ExecuteServerCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := ServerExecutor{
		FlagSet:       flag.NewFlagSet("server", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
	}

	exe.Usage = usage.ExecutorUsageFunc("server", "Runs Enbas in server mode", exe.FlagSet)

	exe.BoolVar(&exe.noIdleTimeout, "no-idle-timeout", false, "Set to true to run the server without a timeout")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(server) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(server) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(server) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// ShowExecutor is the executor for the show command.
type ShowExecutor struct {
	*flag.FlagSet
	printSettings           printer.Settings
	config                  *config.Config
	accountName             internalFlag.StringSliceValue
	getAllAudio             bool
	getAllImages            bool
	getAllVideos            bool
	attachmentIDs           internalFlag.StringSliceValue
	boostedBy               bool
	showInBrowser           bool
	excludeBoosts           bool
	excludeReplies          bool
	fromResourceType        string
	likedBy                 bool
	limit                   int
	listID                  string
	myAccount               bool
	onlyMedia               bool
	onlyPinned              bool
	onlyPublic              bool
	showUserPreferences     bool
	showStatuses            bool
	skipAccountRelationship bool
	statusID                string
	timelineCategory        string
	tag                     string
	resourceType            string
	configDir               string
}

// ExecuteShowCommand initialises and runs the executor for the show command.
func ExecuteShowCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := ShowExecutor{
		FlagSet:       flag.NewFlagSet("show", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
		attachmentIDs: internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("show", "Shows details about a specified resource", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.BoolVar(&exe.getAllAudio, "all-audio", false, "Set to true to play all audio files from the status")
	exe.BoolVar(&exe.getAllImages, "all-images", false, "Set to true to show all images from the status")
	exe.BoolVar(&exe.getAllVideos, "all-videos", false, "Set to true to play all videos from the status")
	exe.Var(&exe.attachmentIDs, "attachment-id", "The ID of the media attachment")
	exe.BoolVar(&exe.boostedBy, "boosted-by", false, "Set to true to see the accounts who boosted the status")
	exe.BoolVar(&exe.showInBrowser, "browser", false, "Set to true to view in the your favourite browser")
	exe.BoolVar(&exe.excludeBoosts, "exclude-boosts", false, "Set to true to exclude statuses that are boosts of another status")
	exe.BoolVar(&exe.excludeReplies, "exclude-replies", false, "Set to true to exclude statuses that are a reply to another status")
	exe.StringVar(&exe.fromResourceType, "from", "", "The resource type to action the target resource from (e.g. status)")
	exe.BoolVar(&exe.likedBy, "liked-by", false, "Set to true to see the accounts who liked (favourited) the status")
	exe.IntVar(&exe.limit, "limit", 20, "Specify the limit of items to display")
	exe.StringVar(&exe.listID, "list-id", "", "The ID of the list in question")
	exe.BoolVar(&exe.myAccount, "my-account", false, "Set to true to specify your account")
	exe.BoolVar(&exe.onlyMedia, "only-media", false, "Set to true to show only the statuses with media attachments")
	exe.BoolVar(&exe.onlyPinned, "only-pinned", false, "Set to true to show only the account's pinned statuses")
	exe.BoolVar(&exe.onlyPublic, "only-public", false, "Set to true to show only the account's public posts")
	exe.BoolVar(&exe.showUserPreferences, "show-preferences", false, "Set to true to view your posting preferences when viewing your account information")
	exe.BoolVar(&exe.showStatuses, "show-statuses", false, "Set to true to view the statuses created from the account you are viewing")
	exe.BoolVar(&exe.skipAccountRelationship, "skip-relationship", false, "Set to true to skip showing your relationship to the account that you are viewing")
	exe.StringVar(&exe.statusID, "status-id", "", "The ID of the status")
	exe.StringVar(&exe.timelineCategory, "timeline-category", "home", "The timeline category")
	exe.StringVar(&exe.tag, "tag", "", "The name of the tag")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(show) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(show) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(show) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// SwitchExecutor is the executor for the switch command.
type SwitchExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	to            string
	configDir     string
}

// ExecuteSwitchCommand initialises and runs the executor for the switch command.
func ExecuteSwitchCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := SwitchExecutor{
		FlagSet:       flag.NewFlagSet("switch", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("switch", "Performs a switch operation (e.g. switching between logged in accounts)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.to, "to", "", "The resource type to action the target resource to (e.g. status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(switch) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(switch) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(switch) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// UnblockExecutor is the executor for the unblock command.
type UnblockExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	resourceType  string
	configDir     string
}

// ExecuteUnblockCommand initialises and runs the executor for the unblock command.
func ExecuteUnblockCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := UnblockExecutor{
		FlagSet:       flag.NewFlagSet("unblock", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("unblock", "Unblocks a resource (e.g. an account)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(unblock) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(unblock) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(unblock) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// UnfollowExecutor is the executor for the unfollow command.
type UnfollowExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	tag           string
	resourceType  string
	configDir     string
}

// ExecuteUnfollowCommand initialises and runs the executor for the unfollow command.
func ExecuteUnfollowCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := UnfollowExecutor{
		FlagSet:       flag.NewFlagSet("unfollow", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("unfollow", "Unfollows a resource (e.g. an account)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.tag, "tag", "", "The name of the tag")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(unfollow) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(unfollow) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(unfollow) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// UnmuteExecutor is the executor for the unmute command.
type UnmuteExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	accountName   internalFlag.StringSliceValue
	statusID      string
	resourceType  string
	configDir     string
}

// ExecuteUnmuteCommand initialises and runs the executor for the unmute command.
func ExecuteUnmuteCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := UnmuteExecutor{
		FlagSet:       flag.NewFlagSet("unmute", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
		accountName:   internalFlag.NewStringSliceValue(),
	}

	exe.Usage = usage.ExecutorUsageFunc("unmute", "Umutes a specific resource (e.g. an account)", exe.FlagSet)

	exe.Var(&exe.accountName, "account-name", "The name of the account")
	exe.StringVar(&exe.statusID, "status-id", "", "The ID of the status")
	exe.StringVar(&exe.resourceType, "type", "", "The type of resource you want to action on (e.g. account, status)")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(unmute) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(unmute) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(unmute) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// VersionExecutor is the executor for the version command.
type VersionExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	full          bool
	configDir     string
}

// ExecuteVersionCommand initialises and runs the executor for the version command.
func ExecuteVersionCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := VersionExecutor{
		FlagSet:       flag.NewFlagSet("version", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
	}

	exe.Usage = usage.ExecutorUsageFunc("version", "Prints the application's version and build information", exe.FlagSet)

	exe.BoolVar(&exe.full, "full", false, "Set to true to print the build information in full")

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(version) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(noColor, "", 0)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(version) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}

// WhoamiExecutor is the executor for the whoami command.
type WhoamiExecutor struct {
	*flag.FlagSet
	printSettings printer.Settings
	config        *config.Config
	configDir     string
}

// ExecuteWhoamiCommand initialises and runs the executor for the whoami command.
func ExecuteWhoamiCommand(
	configDir string,
	noColor bool,
	args []string,
) error {
	exe := WhoamiExecutor{
		FlagSet:       flag.NewFlagSet("whoami", flag.ExitOnError),
		printSettings: printer.Settings{},
		config:        nil,
		configDir:     configDir,
	}

	exe.Usage = usage.ExecutorUsageFunc("whoami", "Prints the account that you are currently logged into", exe.FlagSet)

	// Parse the remaining arguments.
	if err := exe.Parse(args); err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(whoami) flag parsing error: "+err.Error()+".",
		)

		return err
	}

	// Load the configuration from file.
	exeConfig, err := config.NewConfigFromFile(exe.configDir)
	if err != nil {
		printer.PrintFailure(
			printer.NewSettings(noColor, "", 0),
			"(whoami) unable to load configuration: "+err.Error()+".",
		)

		return err
	}
	exe.config = exeConfig

	// Create the printer for the executor.
	exe.printSettings = printer.NewSettings(
		noColor,
		exe.config.Integrations.Pager,
		exe.config.LineWrapMaxWidth,
	)

	// Run the executor.
	if err := exe.Execute(); err != nil {
		printer.PrintFailure(
			exe.printSettings,
			"(whoami) execution error: "+err.Error()+".",
		)

		return err
	}

	return nil
}
